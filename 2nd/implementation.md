# 2-2. Implementation

## 개요
- 시뮬레이션과 완전 탐색
- 구현
    - 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정
    - 대개는 풀이를 떠올리는 것은 쉽지만 소스 코드로 옮기기 어려운 문제
    - 일반적으로 2차원 공간(행렬)에서의 처리를 요구
    - 방향 벡터
        - ```
          # 1. list로 
          dx = [0, -1, 0, 1]
          dy = [1, 0, -1, 0]
          
          # 2. [tuple] 로
          d = [(0, 1), (-1, 0), (0, -1), (1, 0)]  
          ```
    - 예시
        - 알고리즘은 간단한데 코드가 지나칠만큼 길어지는 문제
        - 실수 연산을 다루고, 특정 소숫점 자리까지 출력해야 하는 문제
	    - 문자열을 특정한 기준에 따라서 끊어 처리해야 하는 문제
	    - 적절한 라이브러리를 찾아서 사용해야 하는 문제

### 상하좌우
#### 🤔 문제 상황
- NxN 정사각형 공간 위의 여행가 A
- 가장 왼쪽 위의 좌표이자 시작 좌표는 (1, 1)
	- 실제 코드에서는 0, 0부터 시작한다.
	- 가능한 처리 방법
	    1. 가장 첫 번째 인덱스(0)는 사용하지 않는다
	    2. 각 인덱스에 1씩 더한다
- 여행가는 상, 하, 좌, 우 방향으로 이동할 수 있다.
- 여행가 이동 계획서는 다음과 같다.
	- L: 왼쪽으로 한 칸 이동
	- R: 오른쪽으로 한 칸 이동
	- U: 위쪽으로 한 칸 이동
	- D: 아래쪽으로 한 칸 이동
- NxN 공간을 벗어나는 움직임은 무시된다.
- 계획서와 지도가 주어질 때, 모험가의 마지막 좌표는?

##### 정식화
- 입력 조건
    - 첫째 줄에 공간의 크기를 나타내는 N이 주어진다 (1 <= N <= 100)
	    - 100x100이면 만 개 만큼의 위치가 존재한다
    - 둘째 줄에 여행가 A가 이동할 계획서 내용이 주어진다 (1 <= 이동 횟수 <= 100)
- 출력 조건
    - 첫째 줄에 여행가 A가 최종적으로 도착할 지점의 좌표 (X, Y)를 공백을 기준으로 구분하여 출력한다.
- 제한 조건
    - 시간: 2초
    - 메모리: 128MB
    
#### 🙋 내 해결 아이디어
- 우선 여행계획서 별로 dictionary를 만들자.
	- L: (0, -1)
	- R: (0, 1)
	- U: (-1, 0)
	- D: (1, 0)
- 계획서를 순회하며 다음 포지션이 공간을 벗어나는지 체크 후
- 벗어나면 pass, 그렇지 않으면 업데이트

#### 😃 문제 해결 아이디어
위와 같다.


---

## 구현 문제 풀이
### 문제 1 - 시각
#### 🤔 문제 상황
- 정수 N에 대해 00:00:00부터 N:59:59까지 모든 시각 중 3이 하나라도 포함되는 모든 경우의 수 구하기

##### 정식화
- 입력 조건
    - 정수 N (0 <= N <= 23)
- 출력 조건 
    - 3이 하나라도 포함되는 모든 경우의 수
- 제한 조건
    - 시간 2초
    - 메모리 128MB

#### 🙋 내 해결 아이디어
- 초 / 분 / 시로 나눈다
- 초에서 3이 등장하는 경우를 세어 sec에 저장한다
- 분에서 3이 등장하는 경우를 세어 min에 저장한다
	- 3이 등장하는 경우 + 60
	- 등장하지 않는 경우 +sec
- 시에서 3이 등장하는 경우를 세어 res를 반환한다
	- 3이 등장하는 경우 + 60*60
	- 등장하지 않는 경우 + min
- 위 세가지를 세 개의 반복문으로 구현했는데, 반복이 보인다. 이걸 깔끔하게 만드는 방법은 없을까?
	- 해당 부분은 함수로 만들자
	
#### 😃 문제 해결 아이디어
- 가능한 모든 시각의 경우를 하나씩 모두 세서 풀 수 있는 문제
- 모든 경우의 수는 86,400가지
	- 따라서 컴퓨터는 충분히 모든 경우의 수를 확인할 능력이 있음.
	- 파이썬 연산 속도 2천만/s
- 단순히 시각을 1씩 증가시키면서 3이 하나라도 포함되어 있는지 확인
- 완전 탐색 유형

#### 🙆 내가 배울 점
- 만약 시간이 부족하다면 단순하게 직관적으로 푸는 방법도 고민하자
- 그럴땐 너무 꼬아서 어렵게 생각하지 말자

---

### 문제 2 - 왕실의 나이트
#### 🤔 문제 상황
- 8x8 좌표 평면 특정 칸에 서있는 나이트
행: 1...8, 열: a...h
- 정원 밖으로는 나갈 수 없고
- L자 형태로만 이동할 수 있다
    - 수평 2칸, 수직 1칸
    - 수직 2칸, 수평 1칸
- 나이트의 위치가 주어졌을 때
- 나이트가 이동할 수 있는 경우의 수를 출력하는 프로그램
##### 정식화
- 입력 조건
    - 나이트의 좌표 문자열 열, 행 
        - e.g."a1" 
- 출력 조건
    - 나이트가 이동할 수 있는 경우의 수
- 제한 조건
    - 시간 1초
   
#### 🙋 내 해결 아이디어
- dy, dx를 8개로 나눠서 각 경우 가능한지 체크한 후
- 가능하면 cnt++
- 최종 결과 출력

#### 😃 문제 해결 아이디어
- 요구 사항대로 충실히 구현하면 됨
- 나이트의 8가지 이동 경로를 하나씩 체크
- 리스트를 이용해 8가지 방향에 대한 방향 벡터를 정의하자

#### 🙆 내가 배울 점
- 방향 벡터를 튜플의 리스트로 정의하는 방법도 있구나. 직관적이고 괜찮은 듯

---

### 문제 3 - 문자열 재정렬
#### 🤔 문제 상황
- 알파벳 대문자와 숫자 0~9로 이루어진 문자열 입력
    - 수는 말그대로 수
    - 숫자는 0~9사이의 수를 나타내는 문자
- 모든 알파벳을 오름차순으로 정렬해 이어서 출력한 후,
- 모든 숫자를 더한 값을 이어서 출력하자
- K1KA5CB7 → ABCKK13

##### 정식화
- 입력 조건
    - 하나의 문자열 S
    - 1<= len(S) <= 10000
- 출력 조건
    - 요구하는 정답 출력    
- 제한 조건
    - 시간 1초
    - 메모리 128MB

#### 🙋 내 해결 생각
- 문자열에 대해서 순회한다
- 두 개의 리스트를 만드는데, 하나는 숫자가 들어갈 리스트고 하나는 문자가 들어갈 리스트임
- 숫자 리스트는 나중에 아스키 코드 빼서 int로 만든 후 sum()을 함
    - 코딩하다보니까 그럴 필요가 없음을 깨달음
    - num=0에다가 하나씩 더해서 나중에 str(num) 더하면 됨
- 문자는 정렬 후 join

#### 😃 문제 해결 아이디어
- 문자열에 대해 문자를 하나씩 확인한다
    - 숫자인 경우 따로 합계를 계산한다
    - 알파벳은 별도의 리스트에 저장한다
- 리스트에 저장된 알파벳을 정렬해 출력하고, 합계를 뒤에 붙여 출력하면 정답

#### 🧐 분석 (정당성, 시간 복잡도 등)
##### 시간복잡도
- O(N)
#### 🙆 내가 배울 점
- 숫자가 없을 수도 있다는 예외 케이스를 생각하지 못했다.
    - 숫자가 아예 없다면 0이 출력되지 않고,
    - 숫자가 0 하나만 있는 경우, 맨 뒤에 0이 출력되어야 할 것 같은데
    - 문제에 정확히 나오지 않은 것 같음.
- 문자열(나)과 리스트(동빈님)로 나뉘었는데, 속도가 뭐가 더 빠른지 궁금하다. 
- 문자열 계속 덧셈 말고 <b>list append 후 join<b> 하자
    - 길이가 10000인 문자열에 대해 10번 수행한 실행 시각의 평균은 다음과 같다 
    - [0.00417764 0.00296221]
    - 내 코드를 일부 수정해가며 실험했는데
    - 그 결과, str + operator를 계속 하는 것 보다 list append 후 join 하는 게 더 빠르다.
- 문제를 잘 읽고 예외 케이스는 없을지 항상 생각하자
