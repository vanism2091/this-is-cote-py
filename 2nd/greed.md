# 2-1. Greedy Algorithm

## 개요
- 현재 상황에서 당장 좋은 것만 고르는 방법
- 문제 구현 아이디어를 떠올리기 > 정당성 분석
- 일반적으로 그리디는 최적 해를 보장할 수 없는 경우가  많기에, 정당성 분석을 주의해서 수행하자

### 거스름돈 걸러주기 - 그리디 알고리즘의 예시
#### 🤔 문제 상황
    500, 100, 50, 10 단위의 동전이 있다.
    동전 최소 갯수로 손님에게 거슬러주려고 한다.

#### 😃 문제 해결 아이디어
    가장 큰 화폐 단위부터 차례대로 거슬러준다

#### 🧐 정당성 분석
    큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 조합해 다른 해가 나올 수 없다.
##### 정당성 없는 경우의 예,
    500, 400, 100원 단위, 800원 거슬러줄 때

#### 😋 시간 복잡도 분석
화폐의 종류 K개라고 할 때, O(K)

---

## 그리디 유형 문제 풀이
### 문제 1 - 1이 될 때까지
#### 🤔 문제 상황
어떠한 수 N이 1이 될 떄 까지
두 연산 중 하나를 반복 수행
1. N에서 1을 뺀다
2. N을 K로 나눈다

위의 과정을 수행해야 하는 최소 횟수를 구하는 프로그램
#### 🙋 내 해결 아이디어
위의 과정에서 2를 많이 하는게 무조건 좋을 거라고 생각함

1. N이 1이 될 떄 까지 실제로 while로 반복문을 돌려 해본다. (O)

2. 1보다 작아지기 전까지 N을 K로 계속해서 나눈다.
나눈 횟수가 2가 수행될 횟수이다.
N - K^나눈횟수 : 1이 수행될 횟수이다 (X)

2로 구현하다가 틀린걸 깨닫고 1로 구현

#### 😃 문제 해결 아이디어
주어진 N에 대하여 최대한 많이 나누기를 수행

#### 🧐 분석 (정당성, 시간 복잡도 등)
##### 정당성
Q. 가능하면 최대한 많이 나누는 작업이 최적의 해를 보장할 수 있나?\
A. N이 아무리 큰수여도 K가 2 이상인 경우 K로 계속 나누면 기하급수적으로 빠르게 줄일 수 있다.\
또한 N은 항상 1에 도달하게 된다.(최적의 해 성립)

##### 시간복잡도
나: O(N)
동빈님: O(logN)

#### 🙆 내가 배울 점
- 동빈님은 빼는걸 뺄셈 계산을 통해서 한꺼번에 했다. 따라서 시간복잡도 상 더 효율적으로 수행 가능했다.
- 이 문제의 조건이 10만 이하의 정수이기 때문에, 해당 테크닉 없이도 충분히 통과했을 것이다. 수행 시간과 시간복잡도를 항상 염두에 두자.

---
### 문제 2 - 곱하기 혹은 더하기
#### 🤔 문제 상황
각 자리 숫자가 0~9인 문자열 S.
왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하여 숫자 사이에 x 혹은 = 연산자를 넣어 결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램.
모든 연산은 왼쪽부터 순서대로 이뤄진다.

#### 🙋 내 해결 아이디어
* 현재까지의 합과 다음 숫자를 고려해야 한다.
* 현재까지의 합이 0, 1일 때 다음 숫자에 상관 없이 다음은 무조건 +여야 한다.
* 다음 숫자가 0, 1일 때 무조건 +여야 한다
* 그 외에는 * 를 하면 된다.

#### 😃 문제 해결 아이디어
- 대부분 +보다 x가 값을 크게 만든다
- 두 수 중 하나라도 0 혹은 1인 경우, 더하기를 수행하는 것이 효율적이다
- 두 수에 대하여 연산을 수행할 때 두 수 중 하나라도 1 이하인 경우에는 더하며, 그 외는 곱하면 된다.

#### 🧐 분석 (정당성, 시간 복잡도 등)
##### 정당성
- "대부분(1 이하 제외) +보다 x가 값을 크게 만든다"는 가정은 옳다.
##### 복잡도
O(N)

#### 🙆 내가 배울 점
- 첫 번째 문자를 res에 바로 숫자로 대입한 점
- if 조건문 <=1 로 축약.. :)
---

### 문제 3 - 모험가 길드
#### 🤔 문제 상황
- 마을의 N명의 모험가. 각각의 공포도. 공포도가 높으면 대처 능력 떨어짐
- 공포도가 X인 모험가는 반드시 x명 이상으로 구성한 모험가 그룹에 참여해야 여행을 떠날 수 있다
- 몇 명의 모험가는 마을에 그대로 남아있어도 된다
- 여행을 떠날 수 있는 그룹 수의 최댓값을 구하라

#### 🙋 내 해결 아이디어
- 오름차순으로 소트 먼저 하자
- res, temp를 빈 리스트로 초기화.
- temp에 input list 하나씩 넣어보고
-max(temp) == len(temp)일 때
- temp를 res에 append 후 temp는 초기화
- return len(res)
- 시간 복잡도는 소트+포문 = O(NlogN) + O(N) = O(NlogN)

#### 😃 문제 해결 아이디어
- 오름차순 정렬 이후 공포도가 가장 낮은 모험가부터 하나씩 확인
- 현재 그룹에 포함된 모험가의 수가 현재 확인하고 있는 공포도보다 크거나 같다면 이를  그룹으로 설정하면 된다.

#### 🧐 분석 (정당성, 시간 복잡도 등)
##### 정당성 분석
- 공포도가 오름차순으로 정렬되어 있기에, 항상 최소한의 모험가 수만 포험하여 그룹을 결성하게 된다

#### 🙆 내가 배울 점
- 나는 array로 체킹했다. 동빈님은 int 변수로 체킹했다.
- 후자가 훨씬 공간복잡도 상으로 이득일 것이다.
- list가 내게 더 구현하기 직관적이고 편할 수 있지만, int 변수로 체킹할 수 있는지 다시 한 번 생각해보자. 같은 시간 복잡도라면 당연히 공간 복잡도가 작을수록 좋기 때문.
---