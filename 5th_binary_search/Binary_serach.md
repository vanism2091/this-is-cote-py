- [이진 탐색 나의 정리](#이진-탐색-나의-정리)
- [이진 탐색 개요](#이진-탐색-개요)
- [이진 탐색 기초 문제 풀이](#이진-탐색-기초-문제-풀이)
	- [문제 1 떡볶이 떡 만들기](#문제-1-떡볶이-떡-만들기)
	- [문제 2 정렬된 배열에서 특정 수의 개수 구하기](#문제-2-정렬된-배열에서-특정-수의-개수-구하기)

## 이진 탐색 나의 정리
- 이진 탐색 시 중요하다고 생각하는 것
    - start, end, target
		- target은 문제에 주어져 있다.
		- target을 잘 찾기 위해 start, end의 feature를 무엇으로 설정할 것인가?
	- <= , >=
		- 왼쪽, 오른쪽 탐색 시
		- 등호를 어디에 어떻게 붙일 것인가?
		- 문제를 잘 읽고 분석 후 논리에 맞게 등호를 잘 붙이자 :)
    - import bisect from bisect_left, bisect_right
- 이진 탐색을 사용할 수 있는 문제인가? 
    - 정렬이 되어 있는가?
    - 문제의 input이 굉장히 큰가? (O(N), O(NlogN)으로 풀 수 없는가?)
        - 1초일 때, 파이썬은 대략 [1e7, 2e7]번 연산할 수 있다고 가늠하자
- 이진 탐색 응용
    - count_by_range

## 이진 탐색 개요
- 이진 탐색 알고리즘
    - 리스트 안에 있는 특정한 데이터를 찾기 위해 
	- 순차탐색
		- 앞에서 부터 데이터를 하나씩 확인하는 방법
		- O(N)
	- 이진 탐색
		- 정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 방법
		- 시작점, 끝점, 중간점을 이용해 탐색 범위를 설정한다
		- **O(logN)**
    - 재귀로 하는 방법
    - 반복문으로 하는 방법
- 이진 탐색의 시간 복잡도
	- 단계마다 탐색 범위를 2로 나누는 것과 동일하다.
    - 즉, 연산 횟수는 log_2(N)에 비례한다
	- 시간 복잡도는 O(logN)을 보장한다
- 파이썬 이진 탐색 라이브러리
	- **bisect_left(a, x)**
		- 정렬된 순서를 유지하면서 배열 a에 x를 삽입할 가장 왼쪽 인덱스를 반환
	- **bisect_right(a, x)**
		- 정렬된 순서를 유지하면서 배열 a에 x를 삽입할 가장 오른쪽 인덱스를 반환
- **카운트 바이 레인지**
    - 값이 특정 범위에 속하는 데이터 개수 구하기
	- array, left_value, right_value
	- return bisect_right(array, right_value) - bisect_left(array, left_value)
- **파라메트릭 서치**
	- 최적화 문제를 결정문제(예/아니오)로 바꾸어 해결하는 기법
		- 특정한 조건을 만족하는 가장 알맞는 값을 빠르게 찾는 최적화문제
	- 일반적으로 코테에서 이 문제는 이진 탐색을 이용하여 해결할 수 있음

## 이진 탐색 기초 문제 풀이

### 문제 1 떡볶이 떡 만들기
- 문제 내용
    - 입력 조건
    	- 첫째 줄: 떡 갯수 N: [1, 1e6] 요청 길이 M: [1, 2e9]
    	- 둘째줄: 떡의 개별 높이
    		- 떡 높이의 총합은 항상 M이상이다
    		- [0, 1e9]
    - 출력 조건
    	- 적어도 M만큼의 떡을 집에 가져가기 위해 절단기에 설정할 수 있는 높이의 최댓값
    - 제한 조건
    	- 2초
    	- 메모리 128MB
    - 내용
    	- 떡의 길이는 일정하지 않음. 한 봉지 안의 총 떡 길이는 절단기로 잘라서 맞춤
    	- 절단기에 높이 H를 지정하면 떡을 한 번에 절단
        - 높이가 H보다 긴 떡은 H의 윗 부분이 잘릴 것
    	- 예)
        	- 19, 14, 10, 17이고 H가 15이면 15, 14, 10, 15가 됨
            - 잘린 떡의 길이는 4, 0, 0, 2 이고 손님은 6만큼의 길이를 가져감
    	- 손님이 요청한 총 길이가 M일 때 적어도 M만큼의 떡을 얻기 위해 절단기에 설정할 숫 있는 높이의 최댓값은?
- 내 해결 생각
    1. 떡 개별 높이 list를 오름차순으로 정렬한다
    2. 이진탐색 ㄱㄱ
        - 초기 조건
         	- array, target, start, end
    	- 찾기 조건
        	- sum([i-array[mid] || 0 from i in array]) > target
        	- sum([i-array[mid] || 0 from i in array]) < target
        	- sum([i-array[mid] || 0 from i in array]) == target
        		- 특정 인덱스
        	- 같지 않으면, 범위를 특정해서 리턴해야함.
        		- (idx1, sum1), (idx2, sum2)
- 문제 해결 아이디어
    - 적절한 높이를 찾을 때 까지 이진 탐색을 수행
    	- 높이를 높이면 잘린 떡은 줄어들게 되고
    	- 낮추면 늘어나게 된다
    	- 이 조건때문에 이진탐색을 수행할 수 있다
    - 현재  이 높이로 자르면 조건을 만족할 수 있는가? 를 확인 후 만족 여부에 따라 탐색 범위를 좁혀서 해결
    - 절단기 높이가 0부터 10억까지
    	- 이렇게 큰 탐색 범위를 보면
    	- 가장 먼저 이진 탐색을 떠올려야 한다
    	- 선형 탐색을 한다면 시간초과
    - 문제 풀이 과정
    	1. 시작점 0, 끝점 19, 중간점 9
    		- 아, 끝점을 긴 떡의 가운데 길이로 했구나..
    		- sum(~) > 필요한 떡의 크기가 6이므로, 조건 만족. 결과를 저장한다
		2. 시작점 10, 끝점 19, 중간점 14
			- 만족, 결과 저장, 시작점++
		3. 시작점 15, 끝점 19, 중간점 17
			- False, 결과 저장 안함., 끝점--
		4. 시작점 15, 끝점 16, 중간점 15
			- True, 결과 저장, 시작점 ++
		5. 시작점 16, 끝점 16, 중간점 16
			- False. 결과 저장X. 끝점 --
		6. 시작점 17, 끝점 16
			- 이진탐색 끝
    - 이진 탐색 과정을 반복하면 답을 도출할 수 있다.
    - 중간점의 값은 시간이 지날수록 최적화된 값이 된다
    - 과정을 반복하면서 얻을 수 있는 떡의 길이의 합이 필요한 떡의 길이보다 크거나 같을 때마다 중간점의 값을 기록하면 된다
- 분석
- 내가 배울 점
	- start, end, mid를 잘 설정해야 한다 :)
    	- 나는 end를 떡 배열의 길이, mid를 떡 배열의 가운데 idx로 했는데,
    	- 떡을 자르는 높이로 하면 그럴 필요가 없음
        	- 내 방법은 추가로 계산이 필요하고 더 복잡함.
    	- end: max(떡의 길이) mid: 자를 떡의 길이의 가운데
  	- 문제 해결 아이디어를 본 후 내가 직접 구현한 부분에서,
    	- while 에서 =을 절대 빼먹으면 안된다.
    	- 
            	while start <= end:
        - 나는 sum 구할 때, list comprehension + sum을 했는데
        - 변수 도입하는게 공간 복잡도 측면에서 더 좋을 듯 하다.
	- 알고리즘은 확실히 **다양한 문제에 노출**되어야 하고 그에 더하여 **다양한 풀이에 노출**되어야 하는 것 같다. 
	- 풀었다고 끝내지 말고 다른 풀이도 살펴보고 이런 식으로 생각할 수 있구나, 하고 배우고 그걸 잊지 않고 나중에 써먹도록 기록하자!

### 문제 2 정렬된 배열에서 특정 수의 개수 구하기
- 문제 내용
	- 입력 조건
		- 첫째 줄: 데이터 갯수 N: [1, 1e6] 카운트 대상 x: [-1e9, 1e9]
		- 둘째줄: N개의 원소
	- 출력 조건
		- x인 원소의 개수
		- 존재하지 않는다면 -1 출력
	- 제한 조건
		- 1초
		- 메모리 128MB
	- 내용
		- N개의 원소를 포함하고 있는 수열, 오름차순 정렬
		- x가 등장하는 횟수 계산
		- 단, 시간 복잡도는 O(logN)이어야
- 내 해결 생각
	- O(logN) 이라니 이진 탐색 하라는 말이구나
    - bisect_left, bisect_right를 직접 구현해보자
- 문제 해결 아이디어
	- 문제에서 O(logN) 알고리즘 요구
		- 선형 탐색으로는 시간 초과
		- 데이터가 정렬되어 있기 때문에 이진 탐색 가능
	- 특정 값이 등장하는 첫 번째 위치와 마지막 위치 차이를 계산해 문제 해결 가능
	- 이진 탐색 2번 해서 각각 인덱스 찾기
	- 교재에서는 실제로 구현 코드 소개
	- 유툽에서는 라이브러리로 카운트 바이 레인지 함수를 사용
	- 카운트 바이 레인지는 자주 쓰이므로 별도로 노트에 기록 후 자주 쓰세요